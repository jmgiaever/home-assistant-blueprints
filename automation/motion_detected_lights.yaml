blueprint:
  domain: automation
  name: Motion detected lights
  description: >-
    Description
  input:
    trigger_sensors:
      name: Trigger sensors
      description: >-
        Description
      selector:
        target:
          entity:
            domain: binary_sensor
    synced_lights:
      name: Synced lights
      description: >-
        Description
      selector:
        target:
          entity:
            domain: light
    dim_percentage:
      name: Dim-percentage
      description: >-
        Dim lights to this level (%) of current light level,
        before turning lights off. Current level will be stored
        in a scene. Setting this to 0.0 or 1.0 will skip this action.
      default: 0.3
      selector:
        number:
          max: 1.0
          min: 0.0
          step: 0.01
    after_wait_actions:
      name: Wait actions
      description: >-
        Actions to run to delay further, e.g wait until media player state is off,
        housekeeping mode is off etc.
      default: []
      selector:
        action:
    wait_actions_before_dim:
      name: Wait actions before dim
      description: >-
        Run wait actions before dimming down (not turning off). Set to false/OFF
        if you want wait actions to run after dimming instead, but before turning 
        OFF completely.
      default: true
      selector:
        boolean: 
    delay:
      name: Delay
      description: >-
        Time (minutes) to wait to turn off after last movement was detected.
      selector:
        number:
          min: 0.0
          max: 300.0
          step: 5.0
      default: 3

mode: restart

trigger_variables:
  trigger_sensors_input: !input trigger_sensors
  trigger_sensors: >-
    {% set sensors = namespace(entities=[]) %}
    {% if 'entity_id' in trigger_sensors_input %}
      {% for entity in ([ trigger_sensors_input['entity_id'] ] if trigger_sensors_input['entity_id'] is string else trigger_sensors_input['entity_id']) %}
        {% set sensors.entities = sensors.entities + [entity] %}
      {% endfor %}
    {% endif %}
    {% if 'area_id' in trigger_sensors_input %}
      {% for area in ([ trigger_sensors_input['area_id'] ] if trigger_sensors_input['area_id'] is string else trigger_sensors_input['area_id']) %}
        {% for entity in area_entities(area) if entity.startswith('binary_sensor.') %}
          {% set sensors.entities = sensors.entities + [entity] %}
        {% endfor %}
      {% endfor %}
    {% endif %}
    {% if 'device_id' in trigger_sensors_input %}
      {% for device in ([ trigger_sensors_input['device_id'] ] if trigger_sensors_input['device_id'] is string else trigger_sensors_input['device_id']) %}
        {% for entity in device_entities(device) if entity.startswith('binary_sensor.') %}
          {% set sensors.entities = sensors.entities + [entity] %}
        {% endfor %}
      {% endfor %}
    {% endif %}
    {{ sensors.entities|unique|list }}
  scene_name: >-
    {{ this.entity_id.replace('.', '_') }}

trigger:
  - platform: template
    value_template: >-
      {% set sensors = namespace(triggered=false) %}
      {% for sensor in trigger_sensors if is_state(sensor, 'on') %}
        {% set sensors.triggered = true %}
      {% endfor %}
      {{ sensors.triggered }}
  - platform: event
    event_type: "motion_detected_lights"
    event_data:
      end: "{{ scene_name }}"

variables:
  synced_lights_inputs: !input synced_lights
  synced_lights: >-
    {% set lights = namespace(entities=[]) %}
    {% if 'entity_id' in synced_lights_inputs %}
      {% for entity in ([ synced_lights_inputs['entity_id'] ] if synced_lights_inputs['entity_id'] is string else synced_lights_inputs['entity_id']) %}
        {% set lights.entities = lights.entities + [entity] %}
      {% endfor %}
    {% endif %}
    {% if 'area_id' in synced_lights_inputs %}
      {% for area in ([ synced_lights_inputs['area_id'] ] if synced_lights_inputs['area_id'] is string else synced_lights_inputs['area_id']) %}
        {% for entity in area_entities(area) if entity.startswith('light.') %}
          {% set lights.entities = lights.entities + [entity] %}
        {% endfor %}
      {% endfor %}
    {% endif %}
    {% if 'device_id' in synced_lights_inputs %}
      {% for device in ([ synced_lights_inputs['device_id'] ] if synced_lights_inputs['device_id'] is string else synced_lights_inputs['device_id']) %}
        {% for entity in device_entities(device) if entity.startswith('light.') %}
          {% set lights.entities = lights.entities + [entity] %}
        {% endfor %}
      {% endfor %}
    {% endif %}
    {{ lights.entities|unique|list|sort }}
  invalid_light: >-
    {{ states.light|rejectattr('entity_id', 'in', synced_lights)|map(attribute='entity_id')|first }}
  log_level: warning
  dim_percentage: !input dim_percentage
  delay_minutes: !input delay
  delay_seconds: "{{ delay_minutes * 60 }}"
  wait_actions_before_dim: !input wait_actions_before_dim

action:
  - alias: "Triggered on motion or (any) event"
    if: "{{ trigger.platform != 'event' }}"
    then:

      - alias: "Turn on scene if it already exists, otherwise turn on lights."
        continue_on_error: true # if scenes are empty (might happen after a scene.reload)
        choose:
          conditions: "{{ states.scene | selectattr('attributes.friendly_name', 'eq', scene_name) | list | count == 1 and synced_lights == state_attr('scene.' + scene_name, 'entity_id')|sort }}"
          sequence: # Scene do exist and is valid

            - service: system_log.write
              data:
                level: "{{ log_level }}"
                message: >-
                  Scene «{{ scene_name }}» already exists and contains all lights. Restore scene.
            
            - alias: "Turn on scene for synced lights"
              service: scene.turn_on
              target:
                entity_id: "scene.{{scene_name}}"

        default: # Scene does not exist
          - service: system_log.write
            continue_on_error: true
            data:
              level: "{{ log_level }}"
              message: >-
                Scene «{{ scene_name }} does NOT exist or is INVALID. 
                Entities to sync: {{ synced_lights }} => Turn ON every light sourcce.
        
          - alias: "Turn on synced lights"
            service: light.turn_on
            target:
              entity_id: "{{ synced_lights }}"

      - alias: >-
          Listen for light changes and motion in parallel. 
          Save snapshorts to scene on light changes. 
          End this part of automation when motion stops.
        parallel: 
        # Listen for light changes in parallel and save snapshot to a scene
        # so we dont restore light every time the motion is triggered without being OFF
        
        - alias: >-
            Listen for light changes for as long as this automation lives, 
            means: until event is fired and automation is restarted.
          repeat:
            while: "{{ true }}" 
            sequence:

              - alias: "Store variable with current light values (on or brightness)"
                variables:
                  synced_lights_values: >-
                    {% set lights = namespace(values=[]) %}
                    {% for light in synced_lights %}
                      {%if is_state_attr(light, 'color_mode', 'brightness') %}
                        {% set lights.values = lights.values + [state_attr(light, 'brightness')] %}
                      {% else %}
                        {% set lights.values = lights.values + [states(light)] %}
                      {% endif %}
                    {% endfor %}
                    {{ lights.values }}

              - alias: "Wait for change in any light source"
                wait_template: >-
                  {% set lights = namespace(changed=false) %}
                  {% for light in synced_lights %}
                    {%if is_state_attr(light, 'color_mode', 'brightness') and state_attr(light, 'brightness') != synced_lights_values[loop.index - 1] %}
                      {% set lights.changed = true %}
                    {% elif not is_state_attr(light, 'color_mode', 'brightness') and states(light) != synced_lights_values[loop.index - 1] %}
                      {% set lights.changed = true %}
                    {% endif %}
                  {% endfor %}
                  {{ lights.changed }}

              # Check here if values = 0 / OFF
              - service: system_log.write
                data:
                  level: "{{ log_level }}"
                  message: >-
                    Light levels changed: {{ synced_lights }} from {{ synced_lights_values }}.
                    Saving snapshot to scene «{{ scene_name }}».

              - alias: "Store variable a variable with ON lights."
                variables:
                  synced_lights_on: >-
                    {% set lights = namespace(on=[]) %}
                    {% for light in synced_lights if not is_state(light, 'off') %}
                      {% set lights.on = lights.on + [light] %}
                    {% endfor %}
                    {{ lights.on }}

              - choose:
                  conditions: "{{ synced_lights_on|count == 0 }}"
                  sequence:
                    service: system_log.write
                    data:
                      level: "{{ log_level }}"
                      message: "No lights on: invalidating with {{ invalid_light }} which isn't in {{ synced_lights }}."
                    
              - alias: "Save scene for current change and return to loop. If no lights are ON; invalidate scene."
                service: scene.create
                data:
                  scene_id: "{{ scene_name }}"
                  snapshot_entities: >-
                    {{ synced_lights if synced_lights_on|count != 0 else [ invalid_light ] }}
                    

        - alias: >-
            Listen for motion change, and wait for it to become 'OFF',
            wait for the delay and actions to finish, and then send event to kill parallelism.
          sequence: # @ignore: Missing property "condition"
          
          - alias: "Wait for motion to end."
            wait_template: >-
              {% set sensors = namespace(triggered=false) %}
              {% for sensor in trigger_sensors if is_state(sensor, 'on') %}
                {% set sensors.triggered = true %}
              {% endfor %}
              {{ not sensors.triggered }}
          
          - service: system_log.write
            data:
              level: "{{ log_level }}"
              message: >-
                No motion detected by {{ trigger_sensors }}. Run wait actions
                wait {{ (delay_seconds * 1/3)|int }} seconds,, then end 
                automation (parallelism) by issuing an event, and let automation «re-trigger».

          - alias: "Run and wait for actions to finish"
            choose: 
              conditions: >-
                {{ wait_actions_before_dim }}
              sequence: !input after_wait_actions

          - alias: "Wait for delay to fire event."
            delay:
              seconds: "{{ (delay_seconds * 2/3)|int }}"

          - alias: "Ending: Fire event to restart automation and kill parallel processes"
            event: "motion_detected_lights"
            event_data:
              end: "{{ scene_name }}"
    
    else: # Event was fired

      - service: system_log.write
        data: 
          level: "{{ log_level }}"
          message: "Ending {{ scene_name }}, dim down and eventually turn off {{ synced_lights }}."
      
      - alias: "Calculate average brightness and set dim level"
        variables:
          brightness: >-
            {% set brightness = namespace(levels=[]) %}
            {% for light in synced_lights if is_state(light, 'on') %}
              {% if is_state_attr(light, 'color_mode', 'brightness') and state_attr(light, 'brightness')|int != 0 %}
                {% set brightness.levels = brightness.levels + [ state_attr(light, 'brightness') ] %}
              {% else %}
                {% set brightness.levels = brightness.levels + [ 255 ] %}
              {% endif %}
            {% endfor %}
            {{ 0.0 if brightness.levels|length == 0 else brightness.levels|sum / brightness.levels|length }}
          dim_level: "{{ (brightness * dim_percentage)|int }}"

      - service: system_log.write
        data:
          message: >-
            Light avg-brightness is: {{ brightness }}, now dimming lights 
            with {{ (dim_percentage * 100)|int }}% to {{ dim_level }}".
          level: "{{ log_level }}"
      
      - alias: "Dim lights to a low brightness to alert no motion"
        service: light.turn_on
        target:
          entity_id: >-
            {{ synced_lights }}
        data:
          brightness: "{{ dim_level }}"

      - alias: "Run and wait for actions to finish"
        choose: 
          conditions: >-
            {{ not wait_actions_before_dim }}
          sequence: !input after_wait_actions
      
      - alias: "Wait for dim to be recognized by anyone before turning off lights"
        delay: 
          seconds: "{{ (delay_seconds * 1/3)|int }}"

      - alias: "Turn off lights"
        service: light.turn_off
        target:
          entity_id: "{{ synced_lights }}"

      # - alias: "Invalidate scene."
      #   service: scene.create
      #   data:
      #     scene_id: "{{ scene_name }}"
      #     snapshot_entities: "{{ [ invalid_light ] }}"